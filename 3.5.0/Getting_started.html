

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Getting started &mdash; Horace 3.5.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Advanced use" href="Advanced_use.html" />
    <link rel="prev" title="Support and updates" href="Support_and_updates.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Horace
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="The_Horace_Rationale.html">The Horace Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="Download_and_setup.html">Download and setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="Support_and_updates.html">Support and updates</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#creating-an-sqw-file">Creating an SQW file</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-visualisation">Data visualisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-data-manipulation">Basic data manipulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulations">Simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fitting">Fitting</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Advanced_use.html">Advanced use</a></li>
<li class="toctree-l1"><a class="reference internal" href="Horace_GUI.html">Horace GUI</a></li>
<li class="toctree-l1"><a class="reference internal" href="Changing_Horace_settings.html">Changing Horace settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="Planning_a_Horace_scan.html">Planning a Horace scan</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generating_SQW_files.html">Generating SQW files</a></li>
<li class="toctree-l1"><a class="reference internal" href="Manipulating_and_extracting_data_from_SQW_files_and_objects.html">Manipulating and extracting data from SQW files and objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="Correcting_for_sample_misalignment.html">Correcting for sample misalignment</a></li>
<li class="toctree-l1"><a class="reference internal" href="Data_diagnostics.html">Data diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="Symmetrising_etc.html">Symmetrising etc</a></li>
<li class="toctree-l1"><a class="reference internal" href="Unary_operations.html">Unary operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Binary_operations.html">Binary operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Plotting.html">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="Simulation.html">Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Multifit.html">Multifit</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tobyfit.html">Tobyfit</a></li>
<li class="toctree-l1"><a class="reference internal" href="List_of_functions.html">List of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Input_file_formats.html">Input file formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_scripts.html">Example scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="How_to_cite_Horace.html">How to cite Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="Papers_citing_Horace.html">Papers citing Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="Known_bugs.html">Known bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Become_a_developer.html">Become a developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="For_Developers.html">For Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Developer_info.html">Developer info</a></li>
<li class="toctree-l1"><a class="reference internal" href="General_disclaimer.html">General disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Privacy_policy.html">Privacy Policy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Horace</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Getting started</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Getting_started.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started">
<h1>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<p>In order to get going with Horace we suggest that you take a little time to familiarise yourself with the program. To aid this we have created the following step-by-step guide that takes you through the process of converting SPE files into a format useable by Horace, and then shows you how to do different kinds of plot, how to manipulate your data, and finally how to simulate and fit your data. To do this we will refer to the demonstration files included in</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span>\\<span class="n">mprogs</span>\\<span class="n">Horace</span>\\<span class="n">demo</span>\\
</pre></div>
</div>
<p>which relate to a real experiment to investigate spin excitations in Fe using the MAPS spectrometer at ISIS.</p>
<p>Before starting you must first extract the data files from the supplied zip file. You should find SPE files with names MAP11014.SPE, MAP11016.SPE, …, MAP11060.SPE, as well as a PAR file called demo_par.PAR and a PHX file called demo_phx.PHX.</p>
<div class="section" id="creating-an-sqw-file">
<h2>Creating an SQW file<a class="headerlink" href="#creating-an-sqw-file" title="Permalink to this headline">¶</a></h2>
<p>The first step in using Horace is to make your dataset from all of your relevant SPE files. How this works depends somewhat on the properties of your computer, specifically the amount of memory available, and is dealt with <a class="reference internal" href="Download_and_setup.html#system-requirements"><span class="std std-ref">here</span></a>. On most machines (on which the available RAM is &lt;10GB) the dataset is written to a new file with the extension .SQW, and intermediate .TMP files, which contain axes projection information, are written as Horace combines the data. Once you have created your SQW file and are happy with it then you can delete these intermediate .TMP files if you wish, although it is generally a good idea to keep for a few days them unless disk space is a problem for you, in case you wish to re-generate your SQW file. For special cases where large amounts of memory are available then the creation of .TMP files is unnecessary and the SQW file can be created directly. This latter case is dealt with in the section of this manual detailing <a class="reference internal" href="Advanced_use.html#advanced-use"><span class="std std-ref">advanced use</span></a>, for the rest of the following we shall assume you are running a machine with less memory.</p>
<p>In addition to your data there is one other file that is required – the parameter file for the instrument that you used to collect the data. This file has the extension .PAR, and is <strong>not</strong> the same as a PHX file. If you try to use a PHX file with Horace you will just get an error message! The .PAR file for the instrument you used to generate your data can be obtained from the instrument scientist. It is important that you have the correct version of this file for the configuration of the instrument as it was when you used it (much like for the PHX file).</p>
<p>Let’s now run through a simple example. To do this we’ll need some example SPE files and a PAR file. The script file containing all of the commands described below is located in</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">C:\\mprogs\\Horace\\demo\\demo_make_sqw_fe.m</span></code></p>
</div></blockquote>
<p>First we need to tell Horace where the SPE files are, so we write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">indir</span><span class="o">=</span><span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">mprogs</span><span class="se">\\</span><span class="s1">Horace</span><span class="se">\\</span><span class="s1">demo</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>We also need to know where the PAR file is, and where the SQW file that we’re making is going to go:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">par_file</span><span class="o">=</span><span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">mprogs</span><span class="se">\\</span><span class="s1">Horace</span><span class="se">\\</span><span class="s1">demo</span><span class="se">\\</span><span class="s1">demo_par.par&#39;</span><span class="p">;</span>
<span class="n">sqw_file</span><span class="o">=</span><span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">mprogs</span><span class="se">\\</span><span class="s1">Horace</span><span class="se">\\</span><span class="s1">demo</span><span class="se">\\</span><span class="s1">demo_fe_sqw.sqw;&#39;</span>
</pre></div>
</div>
<p>Next we need to specify the (fixed) incident energy that was used and the geometry of the spectrometer. In this case all of the data were taken using Ei=787meV on a direct geometry spectromter, so we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">efix</span><span class="o">=</span><span class="mi">787</span><span class="p">;</span>
<span class="n">emode</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>If we were using an indirect geometry spectrometer then we would have written</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">emode</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>We cannot combine data from different spectrometers, so <code class="docutils literal notranslate"><span class="pre">emode</span></code> is always 1 or 2.</p>
<p>If we had used multiple incident energies then we would have made <code class="docutils literal notranslate"><span class="pre">efix</span></code> a vector whose length was the number of SPE files we wish to combine and whose elements were the incident energy for each SPE file.</p>
<p>We now need to tell Horace the lattice parameters of the sample:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alatt</span><span class="o">=</span><span class="p">[</span><span class="mf">2.87</span><span class="p">,</span><span class="mf">2.87</span><span class="p">,</span><span class="mf">2.87</span><span class="p">];</span>
<span class="n">angdeg</span><span class="o">=</span><span class="p">[</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">];</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alatt</span></code>, which can be a row vector or a column vector, gives the lattice parameters <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angdeg</span></code>, which can also be a row vector or a column vector, gives the lattice angles <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code>, and <code class="docutils literal notranslate"><span class="pre">gamma</span></code>.</p></li>
</ul>
<p>Then we need to specify the orientation of the crystal with respect to the incident beam and the spectrometer. We do this by specifying the scattering plane with two orthogonal vectors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
<span class="n">v</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>The vector <strong>``u``</strong> defines the direction in the <strong>(h,k,l)</strong> frame of the incident beam (so in the above example the crystal’s (1,0,0) direction is parallel to the incident beam). The vector <strong>``v``</strong> may be perpendicular to <strong>``u``</strong> (although it does not have to be) and lies in the equatorial plane of the spectrometer (i.e. the horizontal plane on MERLIN and MAPS). Thus the cross product of <strong>``u``</strong> and <strong>``v``</strong> should point up/down the sample stick.</p>
<p>If after your experiment you realise that your crystal was not aligned how you thought it was, all is not lost! Horace allows you to specify some <em>virtual goniometer</em> angles which tell the program how to convert the supplied (incorrect) co-ordinate frame <strong>``u``</strong> and <strong>``v``</strong> to the real one. Of course you should make every effort to ensure your sample was correctly aligned, in which case you write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">omega</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">dpsi</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">gl</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">gs</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The definitions of these angles are best described with reference to the picture below:</p>
<a class="reference internal image-reference" href="_images/Gonio_angle_definitions.jpg"><img alt="Virtual goniometer angle definitions" src="_images/Gonio_angle_definitions.jpg" style="width: 300px;" /></a>
<p>In this diagram the nominal vectors <strong>``u``</strong> and <strong>``v``</strong> are those supplied to Horace, whereas <strong>``u``</strong><code class="docutils literal notranslate"><span class="pre">'</span></code> and <strong>``v``</strong><code class="docutils literal notranslate"><span class="pre">'</span></code> are the actual vectors. <code class="docutils literal notranslate"><span class="pre">gl</span></code> and <code class="docutils literal notranslate"><span class="pre">gs</span></code> deal with misorientation about axes which lie in the spectrometer’s equatorial plane, whereas <code class="docutils literal notranslate"><span class="pre">dpsi</span></code> deals with misorientations about a vector perpendicular to this plane. <code class="docutils literal notranslate"><span class="pre">omega</span></code> is the angle by which the <code class="docutils literal notranslate"><span class="pre">gs</span></code> axis is rotated compared to the nominal vector <strong>``u``</strong>.</p>
<p>In principle this means that you could put a single crystal with unknown orientation into the spectrometer and conduct your experiment. However this is not a good idea, because the direction about which you rotate your crystal may not be the optimum for you to get all of the data that you want to, since the detectors do not cover <span class="math notranslate nohighlight">\(4 \\pi\)</span> steradians.</p>
<p>Now we’ve told Horace all about the setup of the spectrometer we can go on to specify how our experiment was conducted and which SPE files will contribute to our dataset.</p>
<p>Suppose, as is the case here, we want to combine 24 SPE files, and that the angle psi was different for each one. <code class="docutils literal notranslate"><span class="pre">psi</span></code> is a vector, which in this case has 24 elements. We could write it out explicitly, however in our example we took data in equal steps of psi between 0 degrees and -23 degrees (1 degree steps), so we can use a Matlab trick:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nfiles</span><span class="o">=</span><span class="mi">24</span><span class="p">;</span>
<span class="n">psi</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">(</span><span class="n">nfiles</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">nfiles</span><span class="p">);</span>
</pre></div>
</div>
<p>Horace needs to know the name of all 24 SPE files. To do this they are combined into a single object – a cell array, which is a Matlab data format you can read about in the Matlab help. In this case each element of the cell array is a string which specifies the location of our SPE files. We could write this out explicitly, however in this example the SPE files are numbered sequentially, so we can take another shortcut:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">spe_file</span><span class="o">=</span><span class="n">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nfiles</span><span class="p">);</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">length</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
  <span class="n">spe_file</span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="o">=</span><span class="p">[</span><span class="n">indir</span><span class="p">,</span><span class="s1">&#39;MAP&#39;</span><span class="p">,</span><span class="n">num2str</span><span class="p">(</span><span class="mi">11012</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="n">i</span><span class="p">)),</span><span class="s1">&#39;.SPE&#39;</span><span class="p">];</span>
<span class="n">end</span>
</pre></div>
</div>
<p>(Note that the extension <code class="docutils literal notranslate"><span class="pre">.spe;1</span></code> is not usual, normally it would be something like <code class="docutils literal notranslate"><span class="pre">.spe</span></code> or <code class="docutils literal notranslate"><span class="pre">.SPE</span></code>. Notice that it does matter whether you write the extension in lower or upper case on Windows. We have found that it does matter on, for example, Red Hat Linux).</p>
<p>The first line creates an empty cell array the right size to take our 24 file strings. Inside the ‘for’ loop the ith element of the cell array is a string specifying where ith SPE file. So the 5th element of the cell array <code class="docutils literal notranslate"><span class="pre">spe_file</span></code> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">spe_file</span><span class="p">{</span><span class="mi">5</span><span class="p">}</span><span class="o">=</span><span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">mprogs</span><span class="se">\\</span><span class="s1">Horace</span><span class="se">\\</span><span class="s1">demo</span><span class="se">\\</span><span class="s1">demo_data</span><span class="se">\\</span><span class="s1">MAP11022.SPE&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>We are now ready to make our SQW file! This is done by a single function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen_sqw</span><span class="p">(</span><span class="n">spe_file</span><span class="p">,</span><span class="n">par_file</span><span class="p">,</span><span class="n">sqw_file</span><span class="p">,</span><span class="n">efix</span><span class="p">,</span><span class="n">emode</span><span class="p">,</span><span class="n">alatt</span><span class="p">,</span><span class="n">angdeg</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">psi</span><span class="p">,</span><span class="n">omega</span><span class="p">,</span><span class="n">dpsi</span><span class="p">,</span><span class="n">gl</span><span class="p">,</span><span class="n">gs</span><span class="p">);</span>
</pre></div>
</div>
<p>If everything has worked then the Matlab command window will show text like this, which will be updated when each successive SPE file is read from the disk.</p>
<a class="reference internal image-reference" href="_images/Screenshot1.png"><img alt="The command window display during gen_sqw" src="_images/Screenshot1.png" style="width: 500px;" /></a>
<p>(Note that the above screenshot was created when processing a larger number of files from the same dataset as has been used for this demo. The only practical difference this makes is to the size of errorbars in 1d cuts, the time taken to process the data, and some of the on-screen printouts.)</p>
<p>Further through the process you should see something like this:</p>
<a class="reference internal image-reference" href="_images/Screenshot2.png"><img alt="The command window display during gen_sqw" src="_images/Screenshot2.png" style="width: 500px;" /></a>
<p>Notice that this was run on a Linux machine, hence the different style of directory name and appearance of the Matlab window.</p>
<p>Horace will now run for some time generating the SQW file. This can be quite a long time, and depends quite a lot on how much memory your computer has and its processor speed. It is probably best at this stage just to leave your computer to run and go for a coffee! As a rough guide 150 SPE files, each of 105MB, would be combined on a machine with 4GB of RAM (with its <a class="reference internal" href="Download_and_setup.html#system-requirements"><span class="std std-ref">3GB switch enabled</span></a>) and a speed of 2.5GHz in about 2 hours.</p>
<p>For this demo the data files have purposely been made much smaller (by using only the low angle detector banks on MAPS, and by only including a limited number of energy bins in the SPE files). Each SPE file is about 18MB, and thus it takes about 8 minutes to process all of the data. If all is well messages will be frequently printed to the Matlab command window to let you know the status of your SQW file generation.</p>
</div>
<div class="section" id="data-visualisation">
<h2>Data visualisation<a class="headerlink" href="#data-visualisation" title="Permalink to this headline">¶</a></h2>
<p>Now that we’ve made our SQW file the next step is to see what the data look like. The first thing to do is to tell the program where the SQW file is located:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_source</span><span class="o">=</span><span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">mprogs</span><span class="se">\\</span><span class="s1">Horace</span><span class="se">\\</span><span class="s1">demo</span><span class="se">\\</span><span class="s1"> demo_fe_sqw.sqw&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>which is of course the location of the SQW file we created in the previous section.</p>
<p>Now we have to define the projection axes for our data visualization. The projection information is contained in a structure array, which in this case we are calling <code class="docutils literal notranslate"><span class="pre">proj_100</span></code>. Two of the fields in this structure array are vectors. These are chosen to define the normalization (so they must be unit vectors). There are also other pieces of information that can be provided about the projection, but these will be dealt with later. So we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proj_100</span><span class="o">.</span><span class="n">u</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
<span class="n">proj_100</span><span class="o">.</span><span class="n">v</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>You can choose any (orthogonal) set of axes to make cuts and visualise your data - you are not limited to the projection axes of the crystal with respect to the spectrometer. This is one of the main advantages of using Horace to visualise your data!</p>
<p>Another piece of projection information that we need to know is whether the projection axes are normalised in Angstroms or reciprocal lattice units. There are 3 letters (for the 3 projection axes, the third of which is the cross product of the other two), <code class="docutils literal notranslate"><span class="pre">'r'</span></code> is used for reciprocal lattice units and <code class="docutils literal notranslate"><span class="pre">'a'</span></code> is used for angstroms.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proj_100</span><span class="o">.</span><span class="n">type</span><span class="o">=</span><span class="s1">&#39;rrr&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, we need to know if we are defining our projection axes relative to some offset. This vector has 4 components, since we could offset in energy as well as the 3 components of <strong>Q</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proj_100</span><span class="o">.</span><span class="n">uoffset</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>We now have all the information needed to make any kind of cut we like. Let’s start by making a 2D slice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w100_2</span><span class="o">=</span><span class="n">cut_sqw</span> <span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">500</span><span class="p">]);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/Screenshot_cut1.png"><img alt="Matlab window during cutting" src="_images/Screenshot_cut1.png" style="width: 500px;" /></a>
<p>This slice has as its axes (0,1,0) and energy. The first two arguments in the function <code class="docutils literal notranslate"><span class="pre">cut_sqw</span></code> are where the data is on the computer, and the details of the projections. The next four arguments give either the integration range or the step size of each component of Q and energy. In this example we are integrating between -0.2 and 0.2 r.l.u. in the (1,0,0) component, and between -0.2 and 0.2 in the (0,0,1) component. The slice axes are (0,0,1) whose step size is 0.05 r.l.u., and energy whose step size is the minimum possible (this would have been specified when you Homered your data). Notice that we’ve specified the energy step size differently from the (0,0,1) step size. If a scalar is used then the whole range of data along that axis will be plotted. If a vector of the form [low,step,high] is used then only data within the range low -&gt; high will be plotted, with step size given by <code class="docutils literal notranslate"><span class="pre">step</span></code>.</p>
<p>We don’t yet get a plot of this slice. All we’ve done here is create an ‘sqw’ object which contains the relevant information. However to plot it all we have to do is write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">w100_2</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/Screenshot_cut2.png"><img alt="2d cut from the data" src="_images/Screenshot_cut2.png" style="width: 301px;" /></a>
<p>The ranges of the axes are not quite right, but we can easily change that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lx</span> <span class="mi">1</span> <span class="mi">3</span>
<span class="n">ly</span> <span class="mi">0</span> <span class="mi">150</span>
<span class="n">lz</span> <span class="mi">0</span> <span class="mi">1</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/Screenshot_cut3.png"><img alt="2d cut from data, with plot axes modified" src="_images/Screenshot_cut3.png" style="width: 301px;" /></a>
<p>This makes the horizontal axis go from 1 to 3, the vertical axis from 0 to 150, and the colour scale go from 0 to 1.</p>
<p>If we wanted to make a 1D cut through the data then the syntax is exactly the same. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w100_1</span><span class="o">=</span><span class="n">cut_sqw</span> <span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">]);</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w100_1</span><span class="p">);</span>
<span class="n">lx</span> <span class="mi">1</span> <span class="mi">3</span>
<span class="n">ly</span> <span class="mf">0.2</span> <span class="mf">0.8</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/Screenshot_1dcut.png"><img alt="1d cut" src="_images/Screenshot_1dcut.png" style="width: 301px;" /></a>
<p>would give us a cut along the (0,k,0) axis at a constant energy of 65meV.</p>
<p>3D slices are also possible. To visualize these the ‘sliceomatic’ program is used. When the plot command is executed a GUI is launched that allows you to plot multiple slices through the data. For example you could plot the same slice with x and y axes of (1,0,0) and (0,1,0) at a range of energies.</p>
<a class="reference internal image-reference" href="_images/Screenshot_3dslice.png"><img alt="Sliceomatic in action" src="_images/Screenshot_3dslice.png" style="width: 501px;" /></a>
<p>It is possible to save your cuts / slices to be viewed again later. This can be done very simply in two ways. If you add an extra argument to the end of <code class="docutils literal notranslate"><span class="pre">cut_sqw</span></code>, then the cut data are sent to a file. For our 1D cut above this would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cut_file</span> <span class="o">=</span> <span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">mprogs</span><span class="se">\\</span><span class="s1">Horace</span><span class="se">\\</span><span class="s1">demo</span><span class="se">\\</span><span class="s1">plots</span><span class="se">\\</span><span class="s1">w100_1.sqw&#39;</span><span class="p">;</span>
<span class="n">w100_1b</span><span class="o">=</span><span class="n">cut_sqw</span> <span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">],</span><span class="n">cut_file</span><span class="p">);</span>
</pre></div>
</div>
<p>Now if we want to read this in again at some later time all we need to do is type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w100_1b</span> <span class="o">=</span> <span class="n">read_sqw</span><span class="p">(</span><span class="n">cut_file</span><span class="p">);</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w100_1b</span><span class="p">);</span>
<span class="n">lx</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">;</span> <span class="n">ly</span> <span class="mf">0.2</span> <span class="mf">0.8</span>
</pre></div>
</div>
<p>Alternatively you can store the cut data in the Matlab workspace, simply by typing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w100_1b</span><span class="o">=</span><span class="n">cut_sqw</span> <span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">]);</span>
</pre></div>
</div>
<p>Note, however, that the variable <code class="docutils literal notranslate"><span class="pre">w100_1b</span></code> will only be stored in the Matlab workspace, so it could easily be overwritten, or lost if you quit Matlab without saving your workspace.</p>
<p>As we stated above, the objects that you created using the <code class="docutils literal notranslate"><span class="pre">cut_sqw</span></code> and <code class="docutils literal notranslate"><span class="pre">cut</span></code> commands are all of the type ‘sqw’. These are the generic objects dealt with by Horace and can represent data that is 0 to 4- dimensional. The sqw objects contain information about the contributing pixels to the cut, which in principle allow things like resolution corrections to be done when you analyse your data. However, in some instances you may not wish to retain this information, for example if you are dealing with lots of large 4-dimensional objects and are worried about running out of memory, or if you do not intend to use the pixel information. If this is the case there are two things you can do, depending on whether you are cutting data from a file or from an object in memory. If cutting data from a file and you do not wish to retain pixel information then the syntax is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w100_2_nopixels</span><span class="o">=</span><span class="n">cut_sqw</span> <span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">500</span><span class="p">],</span><span class="s1">&#39;-nopix&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>If cutting data from an sqw object in memory then the syntax is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w100_1d</span><span class="o">=</span><span class="n">cut</span><span class="p">(</span><span class="n">w100_2</span><span class="p">,</span><span class="mf">0.05</span><span class="p">,[</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">],</span><span class="s1">&#39;-nopix&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">w100_2</span></code> is the 2-dimensional sqw object created earlier.</p>
<p>If you make a cut to create an object that is 2-dimensional, but with no pixel information, then it becomes a new type of Horace object – in this case a ‘d2d’. If the cut creates a 1-d object then it is known as a ‘d1d’, and so on. Most operations that apply to sqw objects also apply to dnd objects, albeit appropriately modified, e.g. the command <code class="docutils literal notranslate"><span class="pre">plot</span></code> applies to both kinds of data. The most notable difference applies to simulation and fitting of data.</p>
</div>
<div class="section" id="basic-data-manipulation">
<h2>Basic data manipulation<a class="headerlink" href="#basic-data-manipulation" title="Permalink to this headline">¶</a></h2>
<p>Horace allows you to manipulate your data in many different ways. The number of manipulation functions supplied with the standard download is quite small, however it is relatively easy to write your own bespoke functions – the syntax can be worked out by looking at the existing functions.</p>
<p>It is important to realise that there are essentially 3 different kinds of function, each with a slightly different syntax. The first set of functions, which will be described first below, are ones which take an existing data set and manipulate it in some way before returning the manipulated dataset. An example of this would be dividing the entire dataset by the Bose factor.</p>
<p>The second kind of function is a general function which takes a number of input vectors, corresponding to the axes of the desired output object and performs a mathematical operation on them to give an n-dimensional output. An example of this would be a function called something like <code class="docutils literal notranslate"><span class="pre">gauss_2d</span></code> which takes two vectors that specify a grid in (<strong>Q</strong>,E)-space and some parameter, and returns a 2D grid with an intensity modeled by a Gaussian.</p>
<p>The final kind of function is a ‘proper’ model of S(<strong>Q</strong>,E), i.e. one which takes all of the values of <strong>Q</strong> and E for a particular dataset and calculates a dispersion relation, say, which is then plugged into a simple harmonic oscillator response function.</p>
<p>With the above caveats in mind, let’s demonstrate two different kinds of data manipulation of the first type discussed above. In the first we will simulate the background for a 2D slice by looking at the signal at high |<strong>Q</strong>| in a 1D cut and then replicating it into 2D and subtracting from the real data. We’ll then demonstrate correcting the data for the Bose-Einstein thermal population factor.</p>
<p>First create a new 2D slice and save to file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cut_file</span> <span class="o">=</span> <span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">mprogs</span><span class="se">\\</span><span class="s1">Horace</span><span class="se">\\</span><span class="s1">demo</span><span class="se">\\</span><span class="s1"> w110.sqw&#39;</span><span class="p">;</span>
<span class="n">cut_sqw</span> <span class="p">(</span><span class="n">data_source</span><span class="p">,</span> <span class="n">proj_110</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.05</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">150</span><span class="p">],</span> <span class="n">cut_file</span><span class="p">);</span>
<span class="n">w110</span> <span class="o">=</span> <span class="n">read_sqw</span><span class="p">(</span><span class="n">cut_file</span><span class="p">);</span>
</pre></div>
</div>
<p>Now make a 1D cut out of this slice along the energy axis, with the integration range along (0,1,0) of 4.8 to 5:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wbackcut</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">w110</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mf">4.8</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span>
</pre></div>
</div>
<p>Next make a new 2D slice by replicating the cut along one of the integration axes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wback</span> <span class="o">=</span> <span class="n">replicate</span><span class="p">(</span><span class="n">wbackcut</span><span class="p">,</span><span class="n">w110</span><span class="p">);</span>
<span class="n">plot</span><span class="p">(</span><span class="n">wback</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/Screenshot_background_replicated.png"><img alt="2d cut made by replicating a 1d cut" src="_images/Screenshot_background_replicated.png" style="width: 300px;" /></a>
<p>This is a 2D slice that is over the same range as w110. We now subtract this from the real data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wdiff</span> <span class="o">=</span> <span class="n">w110</span><span class="o">-</span><span class="n">wback</span><span class="p">;</span>
<span class="n">plot</span><span class="p">(</span><span class="n">wdiff</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/Screenshot_background_subtracted.png"><img alt="Background-subtracted data" src="_images/Screenshot_background_subtracted.png" style="width: 300px;" /></a>
</div>
<div class="section" id="simulations">
<h2>Simulations<a class="headerlink" href="#simulations" title="Permalink to this headline">¶</a></h2>
<p>It is not only possible to plot and manipulate data, it is also possible to simulate an entire dataset, or parts of a dataset. We will illustrate this option using two examples, one that gives a quartet of Gaussian profile peaks, and another that simulates the intensity from a Heisenberg ferromagnet.</p>
<p>It is often the case that you do not have a full model of S(<strong>Q</strong>,E), but rather you just want to determine how a particular peak changes with, for example, temperature or neutron energy transfer. An example would be to monitor the positions and intensities of a quartet peaks. We can generate a slice from our demo data by typing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_template</span><span class="o">=</span><span class="n">cut_sqw</span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.05</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.05</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">]);</span>
</pre></div>
</div>
<p>This should give a plot that looks like this:</p>
<a class="reference internal image-reference" href="_images/Screenshot_CutToSim.png"><img alt="2d data" src="_images/Screenshot_CutToSim.png" style="width: 300px;" /></a>
<p>We will now simulate this using the demonstration function <code class="docutils literal notranslate"><span class="pre">demo_4gauss</span></code>. This is a specially written function which works only for 2D datasets (slices) where both axes are momentum. Read through the code in</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span>\\<span class="n">mprogs</span>\\<span class="n">Horace</span>\\<span class="n">functions</span>\\<span class="n">demo_4gauss</span><span class="o">.</span><span class="n">m</span>
</pre></div>
</div>
<p>to see if you can understand how the function works… It is a far from simple task to write a function that is completely general for any dimensionality of dataset, so you typically write functions such as this that work only for a particular dimensionality. It is important, therefore, for your own book-keeping, that you give the functions sensible names that reflect both what they do and what sort of dataset they apply to.</p>
<p>Now let’s run the function. Instead of using <code class="docutils literal notranslate"><span class="pre">user_func</span></code> we will use <code class="docutils literal notranslate"><span class="pre">func_eval</span></code>. The syntax for functions called by this routine is slightly different:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_sim</span><span class="o">=</span> <span class="n">func_eval</span> <span class="p">(</span><span class="n">w_template</span><span class="p">,</span><span class="nd">@demo_4gauss</span><span class="p">,[</span><span class="mi">6</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mf">0.1</span> <span class="mf">1.25</span> <span class="mi">6</span> <span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
<p>The arguments in the square parentheses are the function inputs, and in this case they correspond respectively to amplitude, satellite position x-coordinate, satellite y-coordinate, central position x-coordinate, central y-coordinate, and background. In general the input to a function called by <code class="docutils literal notranslate"><span class="pre">func_eval</span></code> can take any form (e.g. a cell array, a structure array, a string, etc.), although if you wish to pass anything other than a vector of parameters, such as that shown above, then it must be packed into a cell array.</p>
<p>Notice that the syntax of the input arguments is somewhat different for <code class="docutils literal notranslate"><span class="pre">func_eval</span></code> compared to <code class="docutils literal notranslate"><span class="pre">user_func</span></code>, since with the former we input the parameters as a vector, rather than as separate arguments. The form of the function itself is also different, since it takes some arrays of parameters and calculates an intensity at those points, rather than taking an existing intensity array and modifying it.</p>
<a class="reference internal image-reference" href="_images/Screenshot_SimCut.png"><img alt="2d simulation" src="_images/Screenshot_SimCut.png" style="width: 300px;" /></a>
<p><code class="docutils literal notranslate"><span class="pre">func_eval</span></code> works for both sqw and dnd objects with almost the same syntax. For sqw objects pixel information is simulated according to the intensity calculated for the data grid, whereas for dnd objects this is not required. It is also possible to simulate a dnd from a template sqw object by using an additional keyword argument of the form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dnd_sim</span><span class="o">=</span> <span class="n">func_eval</span> <span class="p">(</span><span class="n">w_template</span><span class="p">,</span><span class="nd">@demo_4gauss</span><span class="p">,[</span><span class="mi">6</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mf">0.1</span> <span class="mf">1.25</span> <span class="mi">6</span> <span class="mi">1</span><span class="p">],</span><span class="s1">&#39;all&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Furthermore one can use the same keyword argument on a template dnd object so that intensity is simulated over the entire data range, rather than just at the points where there are data in the template object.</p>
<p>There is another way of performing a simulation, using a different method and a simulation function with a slightly different input structure. In this case you are fitting a full model of S(<strong>Q</strong>,E), so the function we will demonstrate here is a model appropriate for spin excitations of a 3D Heisenberg ferromagnet. The function is called <code class="docutils literal notranslate"><span class="pre">FM_spinwaves_2dSlice_sqw</span></code>, and it takes as its inputs arrays (or scalars) for all 3 components of <strong>Q</strong> plus energy, as well as the other function parameters (exchange constant etc.). The format of the inputs for this function are thus different from those of <code class="docutils literal notranslate"><span class="pre">demo_4gauss</span></code> - to see the differences it is probably easiest to examine the code for the two functions side-by-side.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_sim</span><span class="o">=</span> <span class="n">sqw_eval</span> <span class="p">(</span><span class="n">w_template</span><span class="p">,</span><span class="nd">@FM_spinwaves_2dSlice_sqw</span><span class="p">,[</span><span class="mi">300</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">10</span> <span class="mi">2</span><span class="p">]);</span>
</pre></div>
</div>
<p>In general it is better to use <code class="docutils literal notranslate"><span class="pre">func_eval</span></code> for simple functions such as Gaussians and so on, and sqw for “proper” models of the scattering. The different syntax makes it easier to keep track of what kind of model for the scattering is being employed. As before, the keyword ‘all’ can be added to the arguments of this function, however in this case it is ignored if the object <code class="docutils literal notranslate"><span class="pre">w_template</span></code> is an sqw object. If <code class="docutils literal notranslate"><span class="pre">w_template</span></code> is a dnd object then as for func_eval the keyword ‘all’ ensures that data are simulated over the entire data range. As with <code class="docutils literal notranslate"><span class="pre">func_eval</span></code>, the parameters passed to the function can either take the form of a vector of numerical parameters, or a cell array comprising any other form of input.</p>
</div>
<div class="section" id="fitting">
<h2>Fitting<a class="headerlink" href="#fitting" title="Permalink to this headline">¶</a></h2>
<p>You can also use Horace to fit your data. It can take quite a long time for the fit to converge, so it is therefore a good idea to provide a good initial guess of the fit parameters. You can work these out simulating and then comparing the result to the data by eye.</p>
<p>For an introduction and overview of how to use the following fitting functions, please read <a class="reference internal" href="Multifit.html#multifit"><span class="std std-ref">Fitting data</span></a>. For comprehensive help, please use the Matlab documentation for the various fitting functions that can be obtained by using the <code class="docutils literal notranslate"><span class="pre">doc</span></code> command, for example <code class="docutils literal notranslate"><span class="pre">doc</span> <span class="pre">d1d/multifit</span></code> (for fitting function like Gaussians to d1d objects) or <code class="docutils literal notranslate"><span class="pre">doc</span> <span class="pre">sqw/multifit_sqw</span></code> (fitting models for S(Q,w) to sqw objects).</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Advanced_use.html" class="btn btn-neutral float-right" title="Advanced use" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Support_and_updates.html" class="btn btn-neutral float-left" title="Support and updates" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Alex Buts, Toby Perring, Nick Battam, Harry Saunders, Duc Le, Chris Marooney

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>